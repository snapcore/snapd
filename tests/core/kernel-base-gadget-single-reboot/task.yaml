summary: Verify that updating all of base, gadget and kernel only needs one reboot

details: |
    Test ensures that all three of the essential snaps (base, gadget and kernel) can be updated
    together with a single reboot. The test then reverts each of the snaps to ensure system is left
    in untouched state. (Otherwise our spread checks will complain).

# don't run on UC16 - not supported there
systems: [ubuntu-core-18-*, ubuntu-core-2*]

environment:
    UPDATE_VARIANT/gadget_reboot: reboot
    UPDATE_VARIANT/gadget_noreboot: no-reboot

    SNAPD_NO_MEMORY_LIMIT: 1
    BLOB_DIR: $(pwd)/fake-store-blobdir

prepare: |
    # To get VERSION_ID defined
    . /etc/os-release

    if [ "$TRUST_TEST_KEYS" = "false" ]; then
        echo "This test needs test keys to be trusted"
        exit
    fi

    snap install remarshal jq
    tests.cleanup defer snap remove remarshal
    tests.cleanup defer snap remove jq

    # does not work for 16, but we don't support 16 for this
    core_snap="core${VERSION_ID}"

    readlink "/snap/pc-kernel/current" > pc-kernel.rev
    readlink "/snap/$core_snap/current" > core.rev
    readlink "/snap/pc/current" > pc.rev
    
restore: |
    if [ "$TRUST_TEST_KEYS" = "false" ]; then
        echo "This test needs test keys to be trusted"
        exit
    fi
    "$TESTSTOOLS"/store-state teardown-fake-store "$BLOB_DIR"
    
execute: |
    # To get VERSION_ID defined
    . /etc/os-release

    if [ "$TRUST_TEST_KEYS" = "false" ]; then
        echo "This test needs test keys to be trusted"
        exit
    fi

    if not snap list pc; then
        echo "This test needs a host using 'pc' gadget snap"
        exit 1
    fi

    # does not work for 16, but we don't support 16 for this
    core_snap="core${VERSION_ID}"
    core_id="$(snap info "$core_snap" | awk -F: '$1 == "snap-id" {sub(/^[^:]+:/, "");print}' | xargs)"
    if os.query is-core20; then
        # snap-id doesn't appear on core20?
        core_id=DLqre5XGLbDqg9jPtiAhRRjDuPVa5X1q
    fi

    if [ "$SPREAD_REBOOT" = 0 ]; then
        echo Downloading snaps needed
        snap download pc-kernel --channel="$VERSION_ID"/edge
        snap download "$core_snap" --edge

        # We run one with a vanilla gadget, and one with another gadget
        cp /var/lib/snapd/snaps/pc_*.snap gadget.snap
        unsquashfs -d pc-snap gadget.snap        
        
        if [ "$UPDATE_VARIANT" = "no-reboot" ]; then
            # prepare a vanilla version
            sed -i -e 's/^version: \(.*\)/version: \1-1/' pc-snap/meta/snap.yaml
            snap pack pc-snap --filename=pc_x1.snap
        else
            cp pc-snap/meta/gadget.yaml gadget.yaml.orig

            system_seed=""
            if os.query is-core20 || os.query is-core22 ; then
                system_seed="--system-seed"
            fi

            # prepare update
            python3 ../gadget-update-pc/generate.py ./gadget.yaml.orig v1 $system_seed > pc-snap/meta/gadget.yaml
            echo 'this is foo-x2' > foo-x2.img
            cp foo-x2.img pc-snap/foo.img
            echo 'this is foo.cfg' > pc-snap/foo.cfg
            if os.query is-core20 || os.query is-core22; then
                echo 'this is foo-seed.cfg' > pc-snap/foo-seed.cfg
            fi
            sed -i -e 's/^version: \(.*\)-1/version: \1-2/' pc-snap/meta/snap.yaml
            snap pack pc-snap --filename=pc_x1.snap
        fi

        snap ack "$TESTSLIB/assertions/testrootorg-store.account-key"
        "$TESTSTOOLS"/store-state setup-fake-store "$BLOB_DIR"

        prepare_snap() {
            local SNAP_NAME="$1"
            local SNAP_ID="$2"
            local SNAP_REV="$3"
            local SNAP_PATH="$4"
            
            cat <<EOF > "$SNAP_NAME-decl-headers.json"
    {"snap-id": "$SNAP_ID"}
    EOF
            cat <<EOF > "$SNAP_NAME-rev-headers.json"
    {"snap-id": "$SNAP_ID", "snap-revision": "$SNAP_REV"}
    EOF

            p=$(fakestore new-snap-declaration --dir "$BLOB_DIR" "$SNAP_NAME" --snap-decl-json "$SNAP_NAME-decl-headers.json")
            snap ack "$p"
            p=$(fakestore new-snap-revision --dir "$BLOB_DIR" "$SNAP_PATH" --snap-rev-json "$SNAP_NAME-rev-headers.json")
            snap ack "$p"
            cp -av "$SNAP_PATH" "$BLOB_DIR/"
        }

        prepare_snap pc UqFziVZDHLSyO3TqSWgNBoAdHbLI4dAH 1000 "$(ls pc_*.snap)"
        prepare_snap pc-kernel pYVQrBcKmBa0mZ4CCN7ExT6jH8rY1hza 1000 "$(ls pc-kernel_*.snap)"
        prepare_snap "$core_snap" "$core_id" 1000 "$(ls ${core_snap}_*.snap)"

        if os.query is-core-ge 20; then
            # on uc20+, snap we booted with is unasserted for extra debugging
            snap install "$(ls ${core_snap}_*.snap)" "$(ls pc_*.snap)" "$(ls pc-kernel_*.snap)" --dangerous --no-wait > refresh-change-id
        else
            # all other platforms, the pc snap is asserted, so no flags
            snap install "$(ls ${core_snap}_*.snap)" "$(ls pc_*.snap)" "$(ls pc-kernel_*.snap)" --no-wait > refresh-change-id
        fi
        
        test -n "$(cat refresh-change-id)"
        change_id="$(cat refresh-change-id)"

        # wait for the link task to be done for base
        retry -n 50 --wait 1 sh -c 'journalctl -b -u snapd | MATCH "Waiting for system reboot"'

        # all three link snaps should be done now, snapd has shutdown, so we cannot
        # use 'snap change' and we need to inspect the state directly (even if
        # snapd was up, it would not respond to API requests as it would be busy
        # retrying auto-connect)
        snap debug state --change "$change_id" /var/lib/snapd/state.json > tasks.state
        # both link snaps are done
        MATCH ' Wait\s+.*Make snap "pc-kernel" .* available' < tasks.state
        MATCH " Done\s+.*Make snap \"$core_snap\" .* available" < tasks.state
        MATCH ' Done\s+.*Make snap "pc" .* available' < tasks.state
        # auto-connect of the base is in doing and waiting for reboot
        MATCH " Do\s+.*Automatically connect eligible plugs and slots of snap \"$core_snap\"" < tasks.state
        # auto-connect of the gadget is queued
        MATCH ' Do\s+.*Automatically connect eligible plugs and slots of snap "pc"' < tasks.state
        # auto-connect of the kernel is queued
        MATCH ' Do\s+.*Automatically connect eligible plugs and slots of snap "pc-kernel"' < tasks.state

        if os.query is-core18; then
            snap debug boot-vars > boot-vars.dump
            MATCH 'snap_mode=try' < boot-vars.dump
            MATCH 'snap_try_core=core18_.*.snap' < boot-vars.dump
            MATCH 'snap_try_kernel=pc-kernel_.*.snap' < boot-vars.dump
        elif os.query is-core20 || os.query is-core22 || os.query is-core24; then
            stat /boot/grub/kernel.efi | MATCH 'pc-kernel.*.snap/kernel.efi'
            stat -L /boot/grub/kernel.efi
            stat /boot/grub/try-kernel.efi | MATCH 'pc-kernel.*.snap/kernel.efi'
            stat -L /boot/grub/try-kernel.efi
        else
            echo "unsupported Ubuntu Core system"
            exit 1
        fi

        REBOOT
    elif [ "$SPREAD_REBOOT" = 1 ]; then
        change_id="$(cat refresh-change-id)"
        # XXX: is this sufficiently robust?
        snap watch "$change_id" || true
        snap changes | MATCH "$change_id\s+Done"
        snap change "$change_id" > tasks.done
        # nothing has failed
        NOMATCH '^Error' < tasks.done
        # nothing was undone
        NOMATCH '^Undone' < tasks.done
        # we did not even try to hijack shutdown (/bin/systemctl) because that
        # could race with snapd (if that wanted to call it), so just check that
        # the system is in a stable state once we have already determined that
        # the change is complete
        # XXX systemctl exits with non-0 when in degraded state
        # Note: on bionic, is-system-running does not support --wait
        retry -n 30 sh -c '(systemctl is-system-running || true) | MATCH "(running|degraded)"'

        # fake refreshes generate revision numbers that are n+1
        expecting_kernel="$(($(grep -o -E '[0-9]+' < pc-kernel.rev) + 1))"
        expecting_gadget="$(($(grep -o -E '[0-9]+' < pc.rev) + 1))"

        # for the base, we are expecting it to be 1 since the previous was 'official'
        expecting_core="1"

        # verify that current points to new revisions
        test "$(readlink /snap/pc-kernel/current | grep -o -E '[0-9]+')" = "$expecting_kernel"
        test "$(readlink /snap/pc/current | grep -o -E '[0-9]+')" = "$expecting_gadget"
        test "$(readlink /snap/$core_snap/current | grep -o -E '[0-9]+')" = "$expecting_core"

        # now we need to revert both snaps for restore to behave properly, start
        # with the kernel
        snap revert pc-kernel --revision "$(cat pc-kernel.rev)"
        REBOOT
    elif [ "$SPREAD_REBOOT" = 2 ]; then
        snap watch --last=revert\?
        # now the gadget
        snap revert pc --revision "$(cat pc.rev)"
        REBOOT
    elif [ "$SPREAD_REBOOT" = 3 ]; then
        snap watch --last=revert\?
        # now the base
        snap revert "$core_snap" --revision "$(cat core.rev)"
        REBOOT
    elif [ "$SPREAD_REBOOT" = 4 ]; then
        snap watch --last=revert\?
        # we're done, verify current symlinks to the right revisions
        test "$(readlink /snap/pc-kernel/current)" = "$(cat pc-kernel.rev)"
        test "$(readlink /snap/pc/current)" = "$(cat pc.rev)"
        test "$(readlink /snap/$core_snap/current)" = "$(cat core.rev)"
    else
        echo "unexpected reboot"
        exit 1
    fi
